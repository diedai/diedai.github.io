---
layout:     post
title:      "java并发包"
subtitle:   " \"1.解决了什么问题？ 2.怎么解决的？\""
date:       2018-10-12 06:00:00
author:     "青乡"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - DataStructure&Algorithm
    - multithread
---


# 解决了什么问题
普通同步的性能问题。


# 如何解决
可重入锁。

# 为什么

# 类
#### 并发List
写时复制ArrayList。

有没有LinkedList？为什么没有？

#### 并发Set

#### 并发Map


# 并发包的作用

1.简单同步

下面2种情况，可以通过简单同步解决。

1）1个操作，包含多个指令

解决的是一个操作，但是这个操作包含了多条计算机指令。

这些指令执行时间不确定，导致多个线程会出现问题。



2）多个操作，但是都在1个方法里



2.并发包

还有一种情况，就是有的代码，包含了多个同步方法。



虽然这些方法每个都是同步的，但是可能在执行1个方法的时候改了数据(比如，数组删除一个元素，数组大小10改为9)，另外一个方法读了数据，直接导致数组越界(数组元素个数还是以前的10)。



并发包就是要解决这个问题。



---

具体怎么解决？实现原理和底层实现？



# 队列

1.普通队列

数组

链表



2.并发包

只有链表实现ConcurrentLinkedQueue。为什么没有数组实现ConcurrentArrayQueue?



#### 为什么没有数组实现ConcurrentArrayQueue?



---

普通队列的实现原理和底层实现？

1.数组

1）数组

存放数据。

2）数组索引指针，不是真的索引

用于指向队列的头和尾。



2.链表

节点类，包含

1）数据

2）对象指针

指向下一个节点。



---

并发包-链表队列的底层实现和实现原理？









# 阻塞队列

什么是阻塞队列？

1.队列

先进先出。



2.阻塞

一直卡在那里。



3.阻塞队列

有个线程，一直读阻塞队列里的数据，

1）来一个数据，就读一个数据

2）不来，就阻塞在那里，等待下一个订单数据的到来

上面是消费者的角度看。



如果从生产者的角度看，

1）一直往队列里写数据

2）没写满，就一直写；

写满了，就阻塞，直到有数据被消费，腾出了一个新的空间






注：非阻塞队列，即普通队列Queue。

1.没有数据，就返回null。

2.数据满了，就插不进去了。





---

什么是生产者-消费者模式？

只是一个设计模式而已。具体包括以下几个部分，

1.数据从哪里读？

有个定时任务去扫库，作用是读数据。

读数据的代码，就叫做生产者。

2.数据放在哪里？

阻塞队列。

3.数据写到哪里？

写数据的代码，就叫做消费者。





---

二者的关系？



---

应用场景？

1.支付系统

订单的生产者-消费者。



使用的是哪一个实现类？数组还是链表？

因为不需要从中间插入和删除数据，所以是数组。



上面说的1的这种情况是错误的，支付系统不是使用阻塞队列，消费者不是一直等待处理数据，服务器客户端程序的服务器才是使用的阻塞队列，但是支付系统的订单不是，因为订单是使用定时任务去扫描生产者放入队列的数据，使用的队列只是普通队列，而不是阻塞队列，没必要阻塞，也不是阻塞的应用场景。



具体是使用的并发链表队列ConcurrentLinkedQueue。



并发包为什么没有并发数组队列？但是阻塞队列是有数组和链表2种实现。





2.服务器客户端程序

服务器是消费者，处理请求。

客户端是生产者，生产请求。



3.其他的任何处理数据和生产数据，都可以看作是生产者-消费者模式





---

底层原理和底层实现？





---

数组阻塞队列和链表阻塞队列的区别？

1.数组

读数据。



2.链表

从中间插入和删除。


--- 
阻塞队列与生产者-消费者设计模式的关系？











