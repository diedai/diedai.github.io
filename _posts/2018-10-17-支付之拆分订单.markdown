---
layout:     post
title:      "支付之拆分订单"
subtitle:   " \"把一个订单的多个商品，拆分为多个订单\""
date:       2018-10-17 06:00:00
author:     "青乡"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 支付
---


# 为什么要拆分订单？
大型电商公司，比如，当当、京东，下订单的时候会让你选择多个商品是否可以单独发货。原因是什么？就是大型电商公司有自建仓库，而且有多个仓库，在不同地点，现在要发货，怎么办，对商家来说最好分开独立发，因为把所有货物弄到一起是一件很麻烦的事情，费钱费力；对用户来说一般来说是一次性一起发比较好，不然要收多次快递，费时间。
https://www.jianshu.com/p/d1f18987525c

---
支付系统为什么要支持拆分订单？
电商支持多个商品拆分，使用支付系统支付的时候，支付系统就也要支持订单拆分。因为要退款。


# 拆分的作用？
同上。

# 流程图

![](https://user-gold-cdn.xitu.io/2018/12/1/16767b23a578a8f3?w=3331&h=1713&f=png&s=300147)

# 在哪里拆分？什么时候拆分？
支付成功之后。
```
@CurrentAction(serviceName = "iOrderServer", operation = "create")

	public int insertDepositAndUpdateOrder(Order paySuccessOrder, OrderDCard orderDCard) {

		try {

			// 更新直连建行付款人账户验证状态

			/*

			 * 20140211 付款人账户姓名、卡号、身份证号全不为空银行才会校验

			 */

			log.info("insertDepositAndUpdateOrder orderID:" + paySuccessOrder.getOrderId());

			if (("1003".equals(paySuccessOrder.getPayChannelId()) || "2160".equals(paySuccessOrder.getPayChannelId()))

					&& StringUtils.isNotBlank(paySuccessOrder.getOrderAttachedInfo().getCustomerName()) && StringUtils.isNotBlank(paySuccessOrder.getOrderAttachedInfo().getCustomerCardNo())

					&& StringUtils.isNotBlank(paySuccessOrder.getOrderAttachedInfo().getCustomerIdNumber())) {

				dao.update("updateVerification", paySuccessOrder);

			}



			if (paySuccessOrder.getDeposit() != null && paySuccessOrder.getDeposit().doubleValue() >= 0.01) {

				log.info("insert_order_deposit id=" + paySuccessOrder.getOrderDeposit().getOrderId() + " amount=" + paySuccessOrder.getOrderDeposit().getAmount());

				dao.save("insert_order_deposit", paySuccessOrder.getOrderDeposit());

			}



			// 插入订单结算表

			dao.save("insert_order_settle_info", paySuccessOrder);



			// 需要拆分的订单，记录订单至t_order_split表，并开启线程，拆分订单

			if (OrderSplitStatus.ORDER_NO_SPLIT.getCode().equals(paySuccessOrder.getSplitStatus()) && FileChangedReloading.containsKey(paySuccessOrder.getMerchantId())) {  //gzh，是否需要拆分，看订单表-是否拆分字段 //拆分之后，怎么处理？定时任务服务。

				OrderSplitRecord orderSplit = new OrderSplitRecord();

				orderSplit.setCreateDate(new Date());

				orderSplit.setOrderId(paySuccessOrder.getOrderId());

				orderSplit.setSplitStatus(OrderSplitStatus.ORDER_NO_SPLIT.getCode());

				dao.save(orderSplit); //这里只是添加一条记录，记录哪个订单需要拆分。真正的拆分在后面处理。

			}else if("1".equals(paySuccessOrder.getCrossBorderFlag())|| "4".equals(paySuccessOrder.getCrossBorderFlag())) {//modify 新增批量跨境

				//如果是跨境外汇，需要保存记录至t_order_exchange(父订单不记录)

				OrderExchange orderExchange = new OrderExchange();

				orderExchange.setOrderId(paySuccessOrder.getOrderId());

				orderExchange.setMerchantId(paySuccessOrder.getMerchantId());

				orderExchange.setPayDate(paySuccessOrder.getPayDate());

				orderExchange.setOrderMoney(paySuccessOrder.getTxMoney());

				orderExchange.setCharges(paySuccessOrder.getCharges());

				orderExchange.setSellCurrency("CNY");

				orderExchange.setSellAmount(paySuccessOrder.getTxMoney().subtract(paySuccessOrder.getCharges()));

				orderExchange.setExchangeType("1");

				orderExchange.setExchangeStatus(ExchangeStatus.APPLY.getState());

				orderExchange.setGoodsName(paySuccessOrder.getOrderAttachedInfo().getGoodsName());

				orderExchange.setCustomerType("0");

				orderExchange.setCustomerName(paySuccessOrder.getOrderAttachedInfo().getCustomerName());

				orderExchange.setCustomerIdcard(paySuccessOrder.getOrderAttachedInfo().getCustomerIdNumber());

				if("4".equals(paySuccessOrder.getCrossBorderFlag())){//modify zj 新增批量跨境

					String settleAccountId = findSettleAccountId(paySuccessOrder.getMerchantId(),paySuccessOrder.getMerchantOrderId());

					if(!StringUtils.isBlank(settleAccountId)){

						orderExchange.setSettleAccountId(settleAccountId);//商家结算账户

					}

				}

				dao.save("insertOrderExchange",orderExchange);

			}

			

			// 点卡支付修改点卡订单状态、增加需转账钱包app记录

			if (paySuccessOrder.getGatewayId().equals("23")) {

				// 将点卡抽取出来

				return dCardPayHandle(paySuccessOrder, orderDCard);

			}



			int updateFlag = dao.update("updateOrderStatusAndPaydateAndCharge", paySuccessOrder);

			if (updateFlag != 1) {

				throw new BaseRuntimeException("orderService update order paySuccess failure");

			}

			return updateFlag;



		} catch (Exception e) {

			log.error("insertDepositAndUpdateOrder error", e);

			throw new BaseRuntimeException("insertDepositAndUpdateOrder error", e);

		}

	}


```

# 拆分之后，怎么处理？

```
/**

 * 定时任务：支付成功父订单拆分子订单，同时调用交易服务进行子订单支付成功处理

 * 

 * @author 

 * 

 */

public class DD4OrderSplitBox {


@SuppressWarnings("unchecked")

	public void excute() {

		if(!start){

			log.info("DD4OrderSplitBox startstatus:"+start);

			return;

		}

		if((null == startDate && null != endDate)

				|| (null != startDate && null == endDate)

				|| (null == startDate && null == endDate && null == orderIds)) {

			log.warn("Invalidate params: startDate = "+startDate+"; endDate = "+endDate+"; orderIds = "+orderIds);

			return;

		}

		try {

			log.info("begin DD4OrderSplitBox......");

			// 查找一段时间中未拆分成功的订单

			Map<String, Object> paramMap = new HashMap<String, Object>();

			paramMap.put("startDate", startDate);

			paramMap.put("endDate", endDate);

			paramMap.put("orderIds", orderIds);

			

			List<OrderSplitRecord> orderSplitList = (List<OrderSplitRecord>) orderDao.find("findUnsplitedOrdersByTimeOrders",paramMap);

			String splitOrders = "";

			for(OrderSplitRecord o:orderSplitList){

				splitOrders += (o.getOrderId()+":"+o.getSplitStatus())+";";

			}

			log.info("splitOrders: "+splitOrders);

			for (OrderSplitRecord orderSplit : orderSplitList) {

				String orderId = orderSplit.getOrderId();

				try {

					DD4OrderSelectResult splitOrderInfo = (DD4OrderSelectResult) orderDao.findObject("selectSplitOrderInfoByOrderId", orderId);

					List<Order> childOrderList = createSplitChildOrders(splitOrderInfo);

					if (StringUtils.isEmpty(splitOrderInfo.getChildOrderMessage())) {

						log.info(orderId + " has no childInfo to split");

						continue;

					}

					if(orderSplit.getSplitStatus().equals("1")){

						/**

						 * 子订单预支付（包括正常预支付和修改订单表父订单为已拆分）

						 */

						PrePayForDD4Response prePayForDD4Response = OrderService.prePayForDD4(childOrderList, splitOrderInfo.getOrderId());

						

						if (!ServiceResponse.RETCODE_SUCCESS.equals(prePayForDD4Response.getRetCode())) {

							log.info("parent order id is " + splitOrderInfo.getOrderId() + ", prePayForDD4 result, result code is " + prePayForDD4Response.getRetCode() + ", msg is"

									+ prePayForDD4Response.getRetMsg());

							continue;

						}

						log.info("parent order id is " + splitOrderInfo.getOrderId() + ", tradeDate is " + prePayForDD4Response.getTradeDate() + ",bankCode is " + prePayForDD4Response.getBankCode());

					}

					

					boolean childOrderAllSucced = true;

					/**

					 * 子订单修改支付成功

					 */

					for (Order order : childOrderList) {

						OrderConfirmRequest orderConfirmRequest = new OrderConfirmRequest();

						orderConfirmRequest.setOrderId(order.getOrderId());

						orderConfirmRequest.setPayChannelOrderId(order.getPayChannelOrderId());

						orderConfirmRequest.setCardNo(order.getCardNo());

						ServiceResponse serviceResponse = OrderService.paySuccConfirm(orderConfirmRequest);

						if (!ServiceResponse.RETCODE_SUCCESS.equals(serviceResponse.getRetCode())) {

							childOrderAllSucced = false;

						}

					}

					// 修改t_order_split表为已拆分并支付成功

					if (childOrderAllSucced) {

						int result = orderDao.update("updateSplitRecordPaySucced", orderId);

						if (1 == result) {

							log.info(orderId + " splited success!");

						} else {

							log.info(orderId + " splited failed! status update failed");

						}

					} else {

						log.warn(orderId + " splited failed! childOrder not paySuccess");

					}

					

				} catch (Exception e) {

					log.error(orderId+" split failed",e);

				}

			}

			log.info("end DD4OrderSplitJob......");

		} catch (Throwable e) {

			log.error(e.getMessage(), e);

		}

	}


```

```
<!-- 查找24小时内未拆分订单 -->

	 <select id="findUnsplitedOrders" resultMap="orderSplitRecords">

	 	<![CDATA[

	 		select 

	 			order_id,create_date,last_modify_date,split_status 

	 		from 

	 			T_ORDER_SPLIT_RECORD

	 		where

	 			create_date >= sysdate-1

	 		and

	 			create_date < sysdate

	 		and

	 			split_status = '1'

	 	]]>

	 </select>





	 <!-- 查找一段时间内未拆分的订单 -->

	 <select id="findUnsplitedOrdersByTimeOrders" resultMap="orderSplitRecords">

 		select 

 			order_id,create_date,last_modify_date,split_status 

 		from 

 			T_ORDER_SPLIT_RECORD

 		where

 			(split_status = '1' or split_status = '2') 

		<isNotNull prepend="and" property="startDate">

		   <![CDATA[ 

		    	create_date >= #startDate#

	 		and

	 			create_date < #endDate#

		     ]]>	

		</isNotNull>

		<isNotNull prepend="and" property="orderIds">

		   <![CDATA[ 

		   		order_id in

		   	]]>	

	   		<iterate property="orderIds" open="(" close=")" conjunction=",">

				#orderIds[]#

			</iterate>

		</isNotNull>

	 		

	 </select>


```

# 父订单和子订单
1.父订单
字段
订单id
父订单id

子订单 //String

2.子订单
子订单，一开始就插入好了，其实就是一条order记录。那么父和子如何关联？见1，即通过父id字段关联。

# 应用场景

# 工作使用
电商。

# 参考
https://my.oschina.net/u/1187675/blog/1618297

https://zhuanlan.zhihu.com/p/24036067?utm_source=wechat_session&utm_medium=social

