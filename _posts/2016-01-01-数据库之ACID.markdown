---
layout:     post
title:      "数据库之ACID"
subtitle:   " \"1.原子性2.一致性3.隔离性4.持久性 \""
date:       2016-01-01 06:00:00
author:     "青乡"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 数据库
---

# 原子操作Automic
只有两种可能：  
1.提交  
2.回滚  

单个事务和多个事务，都是只有两种情况。  

# 所有数据一致性Consistency
银行总共300，ABC各100。  
无论怎么转账操作，总的数据都是300。  

# 单个数据隔离性Isolation
A有100。  
两个事务T1T2(在代码service层，每个事务内部包含两个SQL操作)并发执行写读数据A100，T1或T2的两个SQL会产生以下四种情况：  
1.两次读的数据不一样，假设第二次读了未提交成功的数据  
这种情况最严重，因为读了错误的数据。  
2.两次读的数据不一样，假设第二次读已提交成功的数据  
这种情况比1要好，虽然两次读的数据不一样，但是读的数据没有错误。  
3.两次读的数据一样，但是没有解决范围数据不一致的问题  
加独占行锁，解决两次读数据不一样的问题。  
4.顺序读  
加范围锁/表锁，解决范围数据不一致的问题。  

#### 如何实现
1.脏读  
没加锁，事务A第二次读未提交数据。  

2.幻读  
加锁，只在事务B写的时候加锁。  
事务B写的时候加锁(独占锁，不允许其他事务写读)，确保事务A第二次读的数据是事务B已提交的数据。   
3.重复读(两次读的数据一样)    
事务A一直加行锁(独占锁，不允许其他事务写读)，确保事务A两次读的同一条数据(行数据)一样。 

4.顺序读  
事务A一直加范围锁/表锁(独占锁，不允许其他事务写读)，确保事务A两次的整张表的数据一样。

#### 隔离性与一致性的关系
隔离性的问题会导致读的数据不正确，从而导致写数据不正确，最终数据库的总数据不正确，所以会带来一致性问题。

# 持久化到数据库Duration
保存到关系数据库。

# 附加-事务
#### 数据库层
1.单条SQL  
2.多条SQL  
不管几条SQL，必须commit提交，才会最终生效。否则，只是暂时生效(正因为会暂时生效，才导致了会出现前面说的读未提交数据的情况)，回滚之后，数据修改就失效。



#### 代码service层
几条SQL  
1.一条SQL  
2.多条SQL  

---
如何使用  
spring注解-事务注解。

---
实现原理  
1.底层还是基于数据库提供的事务功能。  
2.代码dao层一般包含一条SQL。  
3.持久层框架mybatis，会根据是否异常来决定是提交commit还是回滚rollback。














