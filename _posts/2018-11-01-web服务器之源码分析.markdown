---
layout:     post
title:      "web服务器之源码分析"
subtitle:   " \"tomcat、jetty\""
date:       2018-11-01 07:00:00
author:     "青乡"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - web
---

# 前言
为什么要看源码？  
因为服务器是每天开发工作都要接触到的东西。其重要性比各种开源框架还要重要。

因为所有的开源框架都是在服务器里跑的。

上面的只是各种完成不同功能的组件而已。

---
目标  
梳理清楚，每个容器的入口在哪里？每个容器在整个流程里的哪一步？具体是源码的哪一块？


只有深入到源码才有效果。

---
从以下几个方面来梳理  
1.大的流程

2.容器

3.Tomcat与servlet的一一对应关系
从4个重要的类来讲

# 大的流程


# 容器


# Tomcat与servlet的一一对应关系
从4个重要的类来讲。

1.servlet类：Servlet/GenericServlet/HttpServlet  
业务类本身。

2.servlet的业务方法  
doGet/doPost/service。

3.ServletConfig  
servlet的init(ServletConfig)。

4.ServletContext  
ServletConfig.getServletContext。

以上是servlet规范里的接口。

---
在tomcat里是什么样的？  
首先搞明白，servlet的一个规范，定义了web服务器的接口，真正的web服务器实现比如tomcat，它就实现了servlet规范里的各个接口，和接口里的所有功能。所以，在tomcat源码里肯定是可以找到以上接口的实现类的。理清楚了这些实现类，以及它们的关系和实现流程，就基本上搞懂了源码了。


1.servlet类
怎么使用？
程序员自定义，一般继承HttpServlet就可以了，然后覆盖doGet/doPost业务方法完成自己的业务功能。

---
底层原理？
在tomcat里，服务器——引擎——主机——上下文——Servlet，这4个都是容器，所谓容器就是servlet容器的意思，顾名思义，作用就是管理Servlet类。

一个简单的servlet规范的实现，即容器的实现，可以不需要那么多的层级，最简单的只需要一层就可以了，比如，如果一个Web服务器只有一个Servlet类，只需要完成一个功能，那么此时web服务器/web容器就是Servlet(在tomcat里，Servlet容器对应的类是Wrapper/StandardWrapper，其他的容器也是容器接口/容器实现类)。

tomcat是一个复杂的web服务器，包含了上述的4个容器，但是平时开发过程当中只需要理解上下文容器和Servlet容器即可，上下文容器就是一个项目的意思，Servlet容器就是对应一个Servlet类，负责创建Servlet类和调用Servlet类的业务方法。

综上所述，关于servlet类最重要的是要理解servlet类和管理它的容器(即Wrapper)。

```
//Servlet容器
public class StandardWrapper extends ContainerBase //所有容器都继承了Containter
    implements ServletConfig, Wrapper, NotificationEmitter {
```

2.业务方法
一般就是增删查改。

3.ServletConfig
如何使用？
ServletConfig出现在Servlet类.init()方法的参数里。
如果在web.xml对servlet类进行了什么配置，这个时候就可以在init方法里通过ServletConfig接口读写相关数据。

---
底层实现和底层原理？
具体流程和步骤，见源码注释。

```
//StandardWrapper
/**
     * Load and initialize an instance of this servlet, if there is not already
     * at least one initialized instance.  This can be used, for example, to
     * load servlets that are marked in the deployment descriptor to be loaded
     * at server startup time.
     */
    public synchronized Servlet loadServlet() throws ServletException { //1.Servlet容器负责加载和创建Servlet类的对象

        if (unloading) {
            throw new ServletException(
                    sm.getString("standardWrapper.unloading", getName()));
        }

        // Nothing to do if we already have an instance or an instance pool
        if (!singleThreadModel && (instance != null))
            return instance;

        PrintStream out = System.out;
        if (swallowOutput) {
            SystemLogHandler.startCapture();
        }

        Servlet servlet;
        try {
            long t1=System.currentTimeMillis();
            // Complain if no servlet class has been specified
            if (servletClass == null) {
                unavailable(null);
                throw new ServletException
                    (sm.getString("standardWrapper.notClass", getName()));
            }

            InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();
            try {
                servlet = (Servlet) instanceManager.newInstance(servletClass);
            } catch (ClassCastException e) {
                unavailable(null);
                // Restore the context ClassLoader
                throw new ServletException
                    (sm.getString("standardWrapper.notServlet", servletClass), e);
            } catch (Throwable e) {
                e = ExceptionUtils.unwrapInvocationTargetException(e);
                ExceptionUtils.handleThrowable(e);
                unavailable(null);

                // Added extra log statement for Bugzilla 36630:
                // https://bz.apache.org/bugzilla/show_bug.cgi?id=36630
                if(log.isDebugEnabled()) {
                    log.debug(sm.getString("standardWrapper.instantiate", servletClass), e);
                }

                // Restore the context ClassLoader
                throw new ServletException
                    (sm.getString("standardWrapper.instantiate", servletClass), e);
            }

            if (multipartConfigElement == null) {
                MultipartConfig annotation =
                        servlet.getClass().getAnnotation(MultipartConfig.class);
                if (annotation != null) {
                    multipartConfigElement =
                            new MultipartConfigElement(annotation);
                }
            }

            // Special handling for ContainerServlet instances
            if ((servlet instanceof ContainerServlet) &&
                    (isContainerProvidedServlet(servletClass) ||
                            ((Context) getParent()).getPrivileged() )) {
                ((ContainerServlet) servlet).setWrapper(this);
            }

            classLoadTime=(int) (System.currentTimeMillis() -t1);

            if (servlet instanceof SingleThreadModel) {
                if (instancePool == null) {
                    instancePool = new Stack<Servlet>();
                }
                singleThreadModel = true;
            }

            initServlet(servlet); //。。。

            fireContainerEvent("load", this);

            loadTime=System.currentTimeMillis() -t1;
        } finally {
            if (swallowOutput) {
                String log = SystemLogHandler.stopCapture();
                if (log != null && log.length() > 0) {
                    if (getServletContext() != null) {
                        getServletContext().log(log);
                    } else {
                        out.println(log);
                    }
                }
            }
        }
        return servlet;

    }
    
    
    
    private synchronized void initServlet(Servlet servlet)
            throws ServletException {

        if (instanceInitialized && !singleThreadModel) return;

        // Call the initialization method of this servlet
        try {
            instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,
                                              servlet);

            if( Globals.IS_SECURITY_ENABLED) {
                boolean success = false;
                try {
                    Object[] args = new Object[] { facade };
                    SecurityUtil.doAsPrivilege("init",
                                               servlet,
                                               classType,
                                               args);
                    success = true;
                } finally {
                    if (!success) {
                        // destroy() will not be called, thus clear the reference now
                        SecurityUtil.remove(servlet);
                    }
                }
            } else {
                servlet.init(facade); //调用servlet类的init方法。可以发现，ServletConfig参数就是在这里传入的。那么ServletConfig在tomcat里的实现类是什么呢？继续看下面代码。
            }

            instanceInitialized = true;

            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet);
        } catch (UnavailableException f) {
            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet, f);
            unavailable(f);
            throw f;
        } catch (ServletException f) {
            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet, f);
            // If the servlet wanted to be unavailable it would have
            // said so, so do not call unavailable(null).
            throw f;
        } catch (Throwable f) {
            ExceptionUtils.handleThrowable(f);
            getServletContext().log("StandardWrapper.Throwable", f );
            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet, f);
            // If the servlet wanted to be unavailable it would have
            // said so, so do not call unavailable(null).
            throw new ServletException
                (sm.getString("standardWrapper.initException", getName()), f);
        }
    }
    
    
        /**
     * The facade associated with this wrapper.
     */
    protected StandardWrapperFacade facade =
        new StandardWrapperFacade(this);
```

```
//StandardWrapperFacade

/**
 * Facade for the <b>StandardWrapper</b> object.
 *
 * @author Remy Maucherat
 */
public final class StandardWrapperFacade
    implements ServletConfig { //3.StandardWrapperFacade实现了ServletConfig接口
```

实际上，Servlet容器不仅实现了Container接口也实现了ServletConfig接口，StandardWrapperFacade也是根据Servlet容器StandardServlet来实现的。


4.ServletContext

# 说明
tomcat源码是7。


