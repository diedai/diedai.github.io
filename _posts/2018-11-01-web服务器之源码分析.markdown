---
layout:     post
title:      "web服务器之源码分析"
subtitle:   " \"tomcat、jetty\""
date:       2018-11-01 07:00:00
author:     "青乡"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - web
---

# 前言
为什么要看源码？  
因为服务器是每天开发工作都要接触到的东西。其重要性比各种开源框架还要重要。

因为所有的开源框架都是在服务器里跑的。

上面的只是各种完成不同功能的组件而已。

---
目标  
梳理清楚，每个容器的入口在哪里？每个容器在整个流程里的哪一步？具体是源码的哪一块？


只有深入到源码才有效果。

---
从以下几个方面来梳理  
1.大的流程

2.容器

3.Tomcat与servlet的一一对应关系
从4个重要的类来讲

# 大的流程
1.启动类Catalina    
启动应用程序。
启动脚本——》启动类。

---
源码  
```
//Catalina
/**
     * Start a new server instance.
     */
    public void start() {

        if (getServer() == null) {
            load();
        }

        if (getServer() == null) {
            log.fatal("Cannot start server. Server instance is not configured.");
            return;
        }

        long t1 = System.nanoTime();

        // Start the new server
        try {
            getServer().start(); //启动服务器
        } catch (LifecycleException e) {
            log.fatal(sm.getString("catalina.serverStartFail"), e);
            try {
                getServer().destroy();
            } catch (LifecycleException e1) {
                log.debug("destroy() failed for failed Server ", e1);
            }
            return;
        }

        long t2 = System.nanoTime();
        if(log.isInfoEnabled()) {
            log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms");
        }

        // Register shutdown hook
        if (useShutdownHook) {
            if (shutdownHook == null) {
                shutdownHook = new CatalinaShutdownHook();
            }
            Runtime.getRuntime().addShutdownHook(shutdownHook);

            // If JULI is being used, disable JULI's shutdown hook since
            // shutdown hooks run in parallel and log messages may be lost
            // if JULI's hook completes before the CatalinaShutdownHook()
            LogManager logManager = LogManager.getLogManager();
            if (logManager instanceof ClassLoaderLogManager) {
                ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                        false);
            }
        }

        if (await) {
            await();
            stop();
        }
    }
```

2.连接器Connector  
接受请求，每个请求来了之后，新建一个独立的线程。

```
//Connector
/**
     * Begin processing requests via this Connector.
     *
     * @exception LifecycleException if a fatal startup error occurs
     */
    @Override
    protected void startInternal() throws LifecycleException {

        // Validate settings before starting
        if (getPort() < 0) {
            throw new LifecycleException(sm.getString(
                    "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
        }

        setState(LifecycleState.STARTING);

        try {
            protocolHandler.start();
        } catch (Exception e) {
            String errPrefix = "";
            if(this.service != null) {
                errPrefix += "service.getName(): \"" + this.service.getName() + "\"; ";
            }

            throw new LifecycleException
            (errPrefix + " " + sm.getString
                    ("coyoteConnector.protocolHandlerStartFailed"), e);
        }

        mapperListener.start();
    }
```

3.处理器Processor    
1）解析客户端套接字请求，得到请求(输入流)和响应(输出流)；  
2）根据输入流里的请求路径，得到servlet类，创建servlet，调用servlet类的.doGet/doPost/service方法。//传递的参数就是请求和响应的门面类，因为门面类实现了HttpServletRequest/Response。

```
//请求处理器AbstractProtocol
public abstract class AbstractProtocol<S> implements ProtocolHandler,
        MBeanRegistration {
        
@Override
    public void start() throws Exception {
        if (getLog().isInfoEnabled())
            getLog().info(sm.getString("abstractProtocolHandler.start",
                    getName()));
        try {
            endpoint.start();//调用NioEndpoint
        } catch (Exception ex) {
            getLog().error(sm.getString("abstractProtocolHandler.startError",
                    getName()), ex);
            throw ex;
        }
    }
```

```
//NioEndpoint
public class NioEndpoint extends AbstractEndpoint<NioChannel> {

/**
     * Start the NIO endpoint, creating acceptor, poller threads.
     */
    @Override
    public void startInternal() throws Exception {

        if (!running) {
            running = true;
            paused = false;

            // Create worker collection
            if ( getExecutor() == null ) {
                createExecutor();
            }

            initializeConnectionLatch();

            // Start poller threads
            pollers = new Poller[getPollerThreadCount()];
            for (int i=0; i<pollers.length; i++) {
                pollers[i] = new Poller();
                Thread pollerThread = new Thread(pollers[i], getName() + "-ClientPoller-"+i);
                pollerThread.setPriority(threadPriority);
                pollerThread.setDaemon(true);
                pollerThread.start();
            }

            startAcceptorThreads();
        }
    }
    
    protected final void startAcceptorThreads() {
        int count = getAcceptorThreadCount();
        acceptors = new Acceptor[count];

        for (int i = 0; i < count; i++) {
            acceptors[i] = createAcceptor();
            String threadName = getName() + "-Acceptor-" + i;
            acceptors[i].setThreadName(threadName);
            Thread t = new Thread(acceptors[i], threadName);
            t.setPriority(getAcceptorThreadPriority());
            t.setDaemon(getDaemon());
            t.start();
        }
    }
```

4.业务类HttpServlet  
处理业务功能；
输出数据到客户端。

# 容器


# Tomcat与servlet的一一对应关系
从4个重要的类来讲。

1.servlet类：Servlet/GenericServlet/HttpServlet  
业务类本身。

2.servlet的业务方法  
doGet/doPost/service。

3.ServletConfig  
servlet的init(ServletConfig)。

4.ServletContext  
ServletConfig.getServletContext。

以上是servlet规范里的接口。

---
在tomcat里是什么样的？  
首先搞明白，servlet的一个规范，定义了web服务器的接口，真正的web服务器实现比如tomcat，它就实现了servlet规范里的各个接口，和接口里的所有功能。所以，在tomcat源码里肯定是可以找到以上接口的实现类的。理清楚了这些实现类，以及它们的关系和实现流程，就基本上搞懂了源码了。


1.servlet类
怎么使用？  
程序员自定义，一般继承HttpServlet就可以了，然后覆盖doGet/doPost业务方法完成自己的业务功能。

---
底层原理？  
在tomcat里，服务器——引擎——主机——上下文——Servlet，这4个都是容器，所谓容器就是servlet容器的意思，顾名思义，作用就是管理Servlet类。

一个简单的servlet规范的实现，即容器的实现，可以不需要那么多的层级，最简单的只需要一层就可以了，比如，如果一个Web服务器只有一个Servlet类，只需要完成一个功能，那么此时web服务器/web容器就是Servlet(在tomcat里，Servlet容器对应的类是Wrapper/StandardWrapper，其他的容器也是容器接口/容器实现类)。

tomcat是一个复杂的web服务器，包含了上述的4个容器，但是平时开发过程当中只需要理解上下文容器和Servlet容器即可，上下文容器就是一个项目的意思，Servlet容器就是对应一个Servlet类，负责创建Servlet类和调用Servlet类的业务方法。

综上所述，关于servlet类最重要的是要理解servlet类和管理它的容器(即Wrapper)。

```
//Servlet容器
public class StandardWrapper extends ContainerBase //所有容器都继承了Containter
    implements ServletConfig, Wrapper, NotificationEmitter {
```

2.业务方法
一般就是增删查改。

3.ServletConfig
如何使用？  
ServletConfig出现在Servlet类.init()方法的参数里。  
如果在web.xml对servlet类进行了什么配置，这个时候就可以在init方法里通过ServletConfig接口读写相关数据。

---
底层实现和底层原理？  
具体流程和步骤，见源码注释。

```
//StandardWrapper
/**
     * Load and initialize an instance of this servlet, if there is not already
     * at least one initialized instance.  This can be used, for example, to
     * load servlets that are marked in the deployment descriptor to be loaded
     * at server startup time.
     */
    public synchronized Servlet loadServlet() throws ServletException { //1.Servlet容器负责加载和创建Servlet类的对象

        if (unloading) {
            throw new ServletException(
                    sm.getString("standardWrapper.unloading", getName()));
        }

        // Nothing to do if we already have an instance or an instance pool
        if (!singleThreadModel && (instance != null))
            return instance;

        PrintStream out = System.out;
        if (swallowOutput) {
            SystemLogHandler.startCapture();
        }

        Servlet servlet;
        try {
            long t1=System.currentTimeMillis();
            // Complain if no servlet class has been specified
            if (servletClass == null) {
                unavailable(null);
                throw new ServletException
                    (sm.getString("standardWrapper.notClass", getName()));
            }

            InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();
            try {
                servlet = (Servlet) instanceManager.newInstance(servletClass);
            } catch (ClassCastException e) {
                unavailable(null);
                // Restore the context ClassLoader
                throw new ServletException
                    (sm.getString("standardWrapper.notServlet", servletClass), e);
            } catch (Throwable e) {
                e = ExceptionUtils.unwrapInvocationTargetException(e);
                ExceptionUtils.handleThrowable(e);
                unavailable(null);

                // Added extra log statement for Bugzilla 36630:
                // https://bz.apache.org/bugzilla/show_bug.cgi?id=36630
                if(log.isDebugEnabled()) {
                    log.debug(sm.getString("standardWrapper.instantiate", servletClass), e);
                }

                // Restore the context ClassLoader
                throw new ServletException
                    (sm.getString("standardWrapper.instantiate", servletClass), e);
            }

            if (multipartConfigElement == null) {
                MultipartConfig annotation =
                        servlet.getClass().getAnnotation(MultipartConfig.class);
                if (annotation != null) {
                    multipartConfigElement =
                            new MultipartConfigElement(annotation);
                }
            }

            // Special handling for ContainerServlet instances
            if ((servlet instanceof ContainerServlet) &&
                    (isContainerProvidedServlet(servletClass) ||
                            ((Context) getParent()).getPrivileged() )) {
                ((ContainerServlet) servlet).setWrapper(this);
            }

            classLoadTime=(int) (System.currentTimeMillis() -t1);

            if (servlet instanceof SingleThreadModel) {
                if (instancePool == null) {
                    instancePool = new Stack<Servlet>();
                }
                singleThreadModel = true;
            }

            initServlet(servlet); //。。。

            fireContainerEvent("load", this);

            loadTime=System.currentTimeMillis() -t1;
        } finally {
            if (swallowOutput) {
                String log = SystemLogHandler.stopCapture();
                if (log != null && log.length() > 0) {
                    if (getServletContext() != null) {
                        getServletContext().log(log);
                    } else {
                        out.println(log);
                    }
                }
            }
        }
        return servlet;

    }
    
    
    
    private synchronized void initServlet(Servlet servlet)
            throws ServletException {

        if (instanceInitialized && !singleThreadModel) return;

        // Call the initialization method of this servlet
        try {
            instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,
                                              servlet);

            if( Globals.IS_SECURITY_ENABLED) {
                boolean success = false;
                try {
                    Object[] args = new Object[] { facade };
                    SecurityUtil.doAsPrivilege("init",
                                               servlet,
                                               classType,
                                               args);
                    success = true;
                } finally {
                    if (!success) {
                        // destroy() will not be called, thus clear the reference now
                        SecurityUtil.remove(servlet);
                    }
                }
            } else {
                servlet.init(facade); //调用servlet类的init方法。可以发现，ServletConfig参数就是在这里传入的。那么ServletConfig在tomcat里的实现类是什么呢？继续看下面代码。
            }

            instanceInitialized = true;

            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet);
        } catch (UnavailableException f) {
            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet, f);
            unavailable(f);
            throw f;
        } catch (ServletException f) {
            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet, f);
            // If the servlet wanted to be unavailable it would have
            // said so, so do not call unavailable(null).
            throw f;
        } catch (Throwable f) {
            ExceptionUtils.handleThrowable(f);
            getServletContext().log("StandardWrapper.Throwable", f );
            instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,
                                              servlet, f);
            // If the servlet wanted to be unavailable it would have
            // said so, so do not call unavailable(null).
            throw new ServletException
                (sm.getString("standardWrapper.initException", getName()), f);
        }
    }
    
    
        /**
     * The facade associated with this wrapper.
     */
    protected StandardWrapperFacade facade =
        new StandardWrapperFacade(this);
```

```
//StandardWrapperFacade

/**
 * Facade for the <b>StandardWrapper</b> object.
 *
 * @author Remy Maucherat
 */
public final class StandardWrapperFacade
    implements ServletConfig { //3.StandardWrapperFacade实现了ServletConfig接口
```

实际上，Servlet容器不仅实现了Container接口也实现了ServletConfig接口，StandardWrapperFacade也是根据Servlet容器StandardServlet来实现的。


4.ServletContext
是什么？  
就是指当前项目。一个项目包含了多个servlet类。

---
如何使用？  
ServletConfig.getServletContext()。

---
底层原理和实现(即tomcat里的实现类)？

```
//ServletConfigFacade
@Override
    public ServletContext getServletContext() {
        if (context == null) {
            context = config.getServletContext();
            if ((context != null) && (context instanceof ApplicationContext))
                context = ((ApplicationContext) context).getFacade();
        }
        return (context);
    }
```

```
//StantdardWrapper
**
     * Return the servlet context with which this servlet is associated.
     */
    @Override
    public ServletContext getServletContext() {

        if (parent == null)
            return (null);
        else if (!(parent instanceof Context))
            return (null);
        else
            return (((Context) parent).getServletContext());

    }
    
        /**
     * The parent Container to which this Container is a child.
     */
    protected Container parent = null; //Servlet父容器，父容器就是上下文容器。
```

```
//StandardContext
 /**
     * Return the servlet context for which this Context is a facade.
     */
    @Override
    public ServletContext getServletContext() {

        if (context == null) {
            context = new ApplicationContext(this); //最终的实现类就是ApplicationContext
            if (altDDName != null)
                context.setAttribute(Globals.ALT_DD_ATTR,altDDName);
        }
        return (context.getFacade());

    }
```

```
//ApplicationContext
/**
 * Standard implementation of <code>ServletContext</code> that represents
 * a web application's execution environment.  An instance of this class is
 * associated with each instance of <code>StandardContext</code>.
 *
 * @author Craig R. McClanahan
 * @author Remy Maucherat
 */
public class ApplicationContext implements ServletContext { //实现了servlet规范里的接口ServletContext

```

# web服务器Server
配置文件web.xml  
Server元素是根元素。代表整台服务器。  
在tomcat里对应的类是StandardServer。

```
//StandardServer
/**
 * Standard implementation of the <b>Server</b> interface, available for use
 * (but not required) when deploying and starting Catalina.
 *
 * @author Craig R. McClanahan
 */
public final class StandardServer extends LifecycleMBeanBase implements Server {
```

```
//Server
public interface Server extends Lifecycle { //继承了生命周期接口，管理整个服务器所有的内容。
```

# 监听器Listener

# 

# 说明
tomcat源码是7。


